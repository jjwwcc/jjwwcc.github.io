<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coastline Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e2e8f0;
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 5px;
        }

        .dashboard-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f1f5f9;
            margin: 0;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #refresh-btn {
            background: rgba(102, 126, 234, 0.2);
            color: #cbd5e1;
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #refresh-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            color: #f1f5f9;
            border-color: rgba(102, 126, 234, 0.5);
        }

        .status-indicators {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
        }

        #last-updated {
            color: #64748b;
            background: rgba(255, 255, 255, 0.05);
            padding: 4px 8px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        #error-message {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid rgba(239, 68, 68, 0.2);
            backdrop-filter: blur(10px);
        }

        .main-dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .metrics-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .chart-panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        #chart-container {
            width: 100%;
            height: 280px;
            background: transparent;
            border-radius: 8px;
            overflow: hidden;
        }

        .section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 24px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
        }

        .key-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }

        .metric-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .metric-item:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .metric-item strong {
            color: #94a3b8;
            font-size: 0.75rem;
            font-weight: 500;
            display: block;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .metric-value {
            font-size: 1.3rem;
            font-weight: 700;
            display: block;
        }

        .positive {
            color: #10b981;
        }

        .negative {
            color: #ef4444;
        }

        .neutral {
            color: #f59e0b;
        }

        .positions-section {
            grid-column: 1 / -1;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            overflow: hidden;
            font-size: 0.85rem;
        }

        th {
            background: rgba(102, 126, 234, 0.1);
            color: #e2e8f0;
            font-weight: 600;
            padding: 10px 8px;
            text-align: left;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: #cbd5e1;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .other-sections {
            display: none;
        }

        .webhook-input-section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        .webhook-input-container h3 {
            color: #f1f5f9;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .webhook-input-container p {
            color: #cbd5e1;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        #webhook-id-field {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            color: #f1f5f9;
            font-size: 1rem;
            min-width: 300px;
            backdrop-filter: blur(10px);
        }

        #webhook-id-field::placeholder {
            color: #94a3b8;
        }

        #webhook-id-field:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        #save-webhook-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        #save-webhook-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .help-text {
            color: #64748b;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .main-dashboard {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .container {
                padding: 10px;
            }

            #chart-container {
                height: 250px;
            }

            .key-metrics {
                grid-template-columns: 1fr 1fr;
            }

            .dashboard-header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .header-controls {
                width: 100%;
                justify-content: space-between;
            }
        }

        /* === Runtime tiny controls (NEW) === */
        .runtime-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 6px;
        }

        .runtime-controls .rc {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 6px 8px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .rc-label {
            font-size: 0.75rem;
            color: #94a3b8;
            letter-spacing: .02em;
        }

        .spinner {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spinner button {
            width: 22px;
            height: 22px;
            line-height: 22px;
            border-radius: 6px;
            border: 1px solid rgba(102, 126, 234, .35);
            background: rgba(102, 126, 234, .18);
            color: #e2e8f0;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            transition: all .2s ease;
        }

        .spinner button:hover {
            background: rgba(102, 126, 234, .3);
        }

        .value-badge {
            min-width: 18px;
            text-align: center;
            font-weight: 700;
            color: #f1f5f9;
        }

        .runtime-status {
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 9999px;
            background: rgba(16, 185, 129, .12);
            border: 1px solid rgba(16, 185, 129, .25);
            color: #10b981;
            display: none;
        }

        @media (max-width: 768px) {
            .runtime-controls {
                flex-wrap: wrap;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="dashboard-header">
            <h1 class="dashboard-title">Coastline Dashboard</h1>
            <div class="header-controls">
                <!-- === Runtime controls (NEW) === -->
                <div class="runtime-controls" title="Adjust runtime caps">
                    <div class="rc">
                        <span class="rc-label">Before&nbsp;3pm</span>
                        <div class="spinner">
                            <button id="before-dec" aria-label="Decrease before 3pm">◀</button>
                            <span id="before-value" class="value-badge">2</span>
                            <button id="before-inc" aria-label="Increase before 3pm">▶</button>
                        </div>
                    </div>

                    <div class="rc">
                        <span class="rc-label">After&nbsp;3pm</span>
                        <div class="spinner">
                            <button id="after-dec" aria-label="Decrease after 3pm">◀</button>
                            <span id="after-value" class="value-badge">1</span>
                            <button id="after-inc" aria-label="Increase after 3pm">▶</button>
                        </div>
                    </div>

                    <span id="runtime-status" class="runtime-status">Saved ✓</span>
                </div>
                <!-- === /Runtime controls (NEW) === -->

                <div class="status-indicators">
                    <span id="last-updated"></span>
                    <span id="error-message"></span>
                </div>
                <button id="refresh-btn">🔄</button>
            </div>
        </div>

        <!-- Webhook ID Input (shown when no ID is stored) -->
        <div id="webhook-id-input" class="webhook-input-section" style="display: none;">
            <div class="webhook-input-container">
                <h3>🔐 Enter Webhook ID</h3>
                <p>Please enter your webhook ID to access the trading data:</p>
                <div class="input-group">
                    <input type="text" id="webhook-id-field" placeholder="e.g., abcde" value="ibcNDjBX2rn" />
                    <button id="save-webhook-btn">Save & Connect</button>
                </div>
                <p class="help-text">This ID will be stored locally in your browser for future use.</p>
            </div>
        </div>

        <div class="main-dashboard">
            <div class="metrics-panel">
                <h2 class="panel-title">📊 Key Metrics</h2>
                <div id="metrics-grid" class="key-metrics"></div>
            </div>

            <div class="chart-panel">
                <h2 class="panel-title">📈 Price Chart</h2>
                <div id="chart-container"></div>
            </div>
        </div>

        <div class="section positions-section" id="positions">
            <h2 class="panel-title">💼 Positions</h2>
            <table>
                <thead>
                    <tr>
                        <th>Idx</th>
                        <th>Entry Time</th>
                        <th>Entry $</th>
                        <th>Qty</th>
                        <th>Open?</th>
                        <th>TP Sub?</th>
                        <th>Closed?</th>
                        <th>Unreal PNL</th>
                        <th>Parent</th>
                        <th>TP</th>
                        <th>Exit</th>
                    </tr>
                </thead>
                <tbody id="positions-body"></tbody>
            </table>
        </div>
    </div>

    <div class="other-sections">
        <div class="section" id="market-data">
            <h2>Market Data</h2>
            <div class="info-grid" id="market-grid"></div>
        </div>
        <div class="section" id="capacity-info">
            <h2>Capacity</h2>
            <div class="info-grid" id="capacity-grid"></div>
        </div>
        <div class="section" id="config-info">
            <h2>Config</h2>
            <div class="info-grid" id="config-grid"></div>
        </div>
        <div class="section" id="summary">
            <h2>Summary</h2>
            <div class="info-grid" id="summary-grid"></div>
        </div>
        <div class="section" id="connection-info">
            <h2>Connection</h2>
            <div class="info-grid" id="connection-grid"></div>
        </div>
    </div>

    <script>
        // Webhook ID management
        const WEBHOOK_BASE_URL = 'https://postget.me';
        let webhookId = null;
        let API_URL = null;

        // Using webhook data only - no external APIs needed
        let chart = null;
        let candlestickSeries = null;
        let lineSeriesMap = new Map();

        // (Removed) Audio beep functionality for position changes due to limited browser support


        // Store real price data sequence locally
        let priceDataSequence = [];
        const MAX_DATA_POINTS = 1200; // Keep last 1200 data points

        // Initialize webhook ID from URL or localStorage
        function initializeWebhookId() {
            // Check URL parameters first
            const urlParams = new URLSearchParams(window.location.search);
            const urlWebhookId = urlParams.get('id');

            if (urlWebhookId) {
                // Store the ID from URL
                localStorage.setItem('webhookId', urlWebhookId);
                webhookId = urlWebhookId;
                console.log('Webhook ID stored from URL:', webhookId);
            } else {
                // Try to get from localStorage
                webhookId = localStorage.getItem('webhookId');
                if (webhookId) {
                    console.log('Webhook ID loaded from localStorage:', webhookId);
                } else {
                    console.log('No webhook ID found');
                }
            }

            // Set API URL if we have an ID
            if (webhookId) {
                API_URL = `${WEBHOOK_BASE_URL}/${webhookId}/data/webhook`;
            }

            return webhookId;
        }

        // Handle webhook ID input and save
        function setupWebhookIdInput() {
            const inputSection = document.getElementById('webhook-id-input');
            const inputField = document.getElementById('webhook-id-field');
            const saveBtn = document.getElementById('save-webhook-btn');

            // Show input section if no webhook ID
            if (!webhookId) {
                inputSection.style.display = 'block';
            }

            // Handle save button click
            saveBtn.addEventListener('click', () => {
                const enteredId = inputField.value.trim();
                if (enteredId) {
                    // Save to localStorage
                    localStorage.setItem('webhookId', enteredId);
                    webhookId = enteredId;
                    API_URL = `${WEBHOOK_BASE_URL}/${webhookId}/data/webhook`;

                    // Hide input section
                    inputSection.style.display = 'none';

                    // Start fetching data
                    fetchData();

                    console.log('Webhook ID saved:', webhookId);
                } else {
                    alert('Please enter a valid webhook ID');
                }
            });

            // Handle Enter key in input field
            inputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveBtn.click();
                }
            });
        }


        // Add real price data to sequence
        function addPriceDataToSequence(webhookData) {
            const currentPrice = webhookData.market_data.current_price;
            const lastBarTime = webhookData.market_data.last_bar_time;
            const now = new Date();
            const currentTime = Math.floor(now.getTime() / 1000);

            // Check if we already have data for this minute (avoid duplicates)
            const lastDataPoint = priceDataSequence[priceDataSequence.length - 1];
            if (lastDataPoint && lastDataPoint.time === currentTime) {
                // Update the existing data point with new price
                lastDataPoint.close = currentPrice;
                lastDataPoint.high = Math.max(lastDataPoint.high, currentPrice);
                lastDataPoint.low = Math.min(lastDataPoint.low, currentPrice);
            } else {
                // Create a new data point
                const newDataPoint = {
                    time: currentTime,
                    open: currentPrice,
                    high: currentPrice,
                    low: currentPrice,
                    close: currentPrice
                };

                // If we have previous data, use previous close as open
                if (lastDataPoint) {
                    newDataPoint.open = lastDataPoint.close;
                    newDataPoint.high = Math.max(newDataPoint.open, currentPrice);
                    newDataPoint.low = Math.min(newDataPoint.open, currentPrice);
                }

                priceDataSequence.push(newDataPoint);
            }

            // Keep only the last MAX_DATA_POINTS
            if (priceDataSequence.length > MAX_DATA_POINTS) {
                priceDataSequence = priceDataSequence.slice(-MAX_DATA_POINTS);
            }

            return priceDataSequence;
        }

        // Initialize Lightweight Charts
        function initChart(symbol, currentPrice) {
            const container = document.getElementById('chart-container');
            if (!window.LightweightCharts) {
                document.getElementById('error-message').textContent = 'Error: Lightweight Charts library failed to load.';
                return false;
            }
            if (chart) {
                chart.remove();
                chart = null;
                candlestickSeries = null;
            }

            try {
                chart = LightweightCharts.createChart(container, {
                    layout: {
                        background: { color: 'transparent' },
                        textColor: '#e2e8f0'
                    },
                    grid: {
                        vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                        horzLines: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: { color: 'rgba(102, 126, 234, 0.5)', width: 1 },
                        horzLine: { color: 'rgba(102, 126, 234, 0.5)', width: 1 }
                    },
                    rightPriceScale: {
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        textColor: '#cbd5e1'
                    },
                    timeScale: {
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        timeVisible: true,
                        secondsVisible: false,
                        textColor: '#cbd5e1'
                    }
                });

                candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#10b981',
                    downColor: '#ef4444',
                    borderVisible: false,
                    wickUpColor: '#10b981',
                    wickDownColor: '#ef4444'
                });

                return true;
            } catch (e) {
                console.error('Chart init error:', e);
                document.getElementById('error-message').textContent = `Chart error: ${e.message}`;
                return false;
            }
        }

        // Update horizontal lines for entry prices and current price
        function updateChartLines(entryPrices, currentPrice) {
            if (!chart || !candlestickSeries) return;

            lineSeriesMap.forEach(series => chart.removeSeries(series));
            lineSeriesMap.clear();

            // Add entry price lines (yellow dashed)
            entryPrices.forEach(price => {
                if (price) {
                    const lineSeries = chart.addLineSeries({
                        color: '#f59e0b',
                        lineWidth: 2,
                        lineStyle: LightweightCharts.LineStyle.Dashed,
                        priceFormat: { type: 'price', precision: 2, minMove: 0.01 }
                    });
                    const data = candlestickSeries.data();
                    if (data.length > 0) {
                        lineSeries.setData([
                            { time: data[0].time, value: price },
                            { time: data[data.length - 1].time, value: price }
                        ]);
                    }
                    lineSeriesMap.set(`entry_${price}`, lineSeries);
                }
            });

            // Add current price line (cyan solid)
            if (currentPrice) {
                const currentPriceSeries = chart.addLineSeries({
                    color: '#06b6d4',
                    lineWidth: 3,
                    lineStyle: LightweightCharts.LineStyle.Solid,
                    priceFormat: { type: 'price', precision: 2, minMove: 0.01 }
                });
                const data = candlestickSeries.data();
                if (data.length > 0) {
                    currentPriceSeries.setData([
                        { time: data[0].time, value: currentPrice },
                        { time: data[data.length - 1].time, value: currentPrice }
                    ]);
                }
                lineSeriesMap.set('current_price', currentPriceSeries);
            }
        }

        async function fetchData() {
            if (!API_URL) {
                document.getElementById('error-message').textContent = 'No webhook ID configured. Please enter your webhook ID.';
                return;
            }

            document.getElementById('error-message').textContent = '';
            try {
                const response = await fetch(API_URL);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                await renderData(data);
                document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleString()}`;
            } catch (error) {
                console.error('Fetch error:', error);
                document.getElementById('error-message').textContent = `Error fetching bot data: ${error.message}`;
            }
        }

        async function renderData(data) {
            const symbol = data.strategy_info.symbol || 'TSLA';
            const currentPrice = data.market_data.current_price || 346.72;
            const beforeCap = data.config_info?.max_open_before_3pm ?? null;
            const afterCap = data.config_info?.max_open_after_3pm ?? null;
            const entryPrices = data.positions
                .filter(p => p.entry_price && p.is_open)
                .map(p => p.entry_price);

            // Initialize chart if not already done
            if (!chart) {
                if (!initChart(symbol, currentPrice)) return;
            }

            // Add current price to sequence and update chart
            const marketData = addPriceDataToSequence(data);
            if (candlestickSeries) {
                candlestickSeries.setData(marketData);
                updateChartLines(entryPrices, currentPrice);
                chart.timeScale().fitContent();
            }

            // Clear any error messages since we're using webhook data
            document.getElementById('error-message').textContent = '';

            // Key Metrics
            const metrics = [
                { key: 'Cap (B/A)', value: (beforeCap != null && afterCap != null) ? `${beforeCap} / ${afterCap}` : 'N/A', color: 'neutral', id: 'cap-metric' },
                { key: 'Current Price ($)', value: currentPrice, color: 'neutral' },
                { key: 'Last Slope', value: data.strategy_info.last_slope, color: data.strategy_info.last_slope > 0 ? 'positive' : data.strategy_info.last_slope < 0 ? 'negative' : 'neutral' },
                { key: 'Positive Streak', value: data.strategy_info.positive_streak, color: 'neutral' },
                { key: 'Cumulative Revenue ($)', value: data.strategy_info.cumulative_revenue_usd, color: data.strategy_info.cumulative_revenue_usd > 0 ? 'positive' : 'negative' },
                { key: 'Total Unrealized PNL ($)', value: data.summary.total_unrealized_pnl, color: data.summary.total_unrealized_pnl > 0 ? 'positive' : data.summary.total_unrealized_pnl < 0 ? 'negative' : 'neutral' },
                { key: 'Projected Revenue ($)', value: data.summary.projected_total_revenue, color: data.summary.projected_total_revenue > 0 ? 'positive' : 'negative' }
            ];

            const grid = document.getElementById('metrics-grid');
            grid.innerHTML = '';
            metrics.forEach(m => {
                const item = document.createElement('div');
                item.className = 'metric-item';

                const valSpan = document.createElement('span');
                valSpan.className = `metric-value ${m.color}`;
                if (m.id) valSpan.id = m.id; // 可选：给“Cap (B/A)”打个 id

                let displayValue = 'N/A';
                if (typeof m.value === 'number') {
                    displayValue = Number.isFinite(m.value) ? m.value.toFixed(2) : 'N/A';
                } else if (m.value != null) {
                    displayValue = String(m.value);
                }
                valSpan.textContent = displayValue;

                item.innerHTML = `<strong>${m.key}</strong>`;
                item.appendChild(valSpan);
                grid.appendChild(item);
            });


            // Positions Table
            const tbody = document.getElementById('positions-body');
            tbody.innerHTML = '';
            if (data.positions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11">No positions</td></tr>';
            } else {
                data.positions.forEach(pos => {
                    const row = document.createElement('tr');
                    const pnlClass = pos.unrealized_pnl > 0 ? 'positive' : pos.unrealized_pnl < 0 ? 'negative' : '';
                    row.innerHTML = `
                        <td>${pos.slot_index}</td>
                        <td>${pos.entry_time}</td>
                        <td>${pos.entry_price?.toFixed(2) ?? 'N/A'}</td>
                        <td>${pos.entry_qty ?? 'N/A'}</td>
                        <td>${pos.is_open ? 'Y' : 'N'}</td>
                        <td>${pos.tp_submitted ? 'Y' : 'N'}</td>
                        <td>${pos.closed_realized ? 'Y' : 'N'}</td>
                        <td class="${pnlClass}">${pos.unrealized_pnl?.toFixed(2) ?? 'N/A'}</td>
                        <td>${pos.parent_order_status ?? 'N/A'}</td>
                        <td>${pos.tp_order_status ?? 'N/A'}</td>
                        <td>${pos.exit_order_status ?? 'N/A'}</td>
                    `;
                    tbody.appendChild(row);
                });
            }
        }
        // === Runtime controls state & posting (NEW) ===
        const RUNTIME_URL = 'https://postget.me/ibcNDjBX2rnp/data/runtime'; // 固定目标
        let maxBefore = 2; // 初始值，可按需改
        let maxAfter = 1; // 初始值，可按需改
        const MIN_VAL = 0, MAX_VAL = 10;

        const clamp = (n) => Math.max(MIN_VAL, Math.min(MAX_VAL, n));

        function updateRuntimeControlsUI() {
            const bv = document.getElementById('before-value');
            const av = document.getElementById('after-value');
            if (bv) bv.textContent = maxBefore;
            if (av) av.textContent = maxAfter;
        }

        function showRuntimeStatus(msg, ok = true) {
            const pill = document.getElementById('runtime-status');
            if (!pill) return;
            pill.textContent = msg;
            pill.style.display = 'inline-block';
            pill.style.background = ok ? 'rgba(16,185,129,.12)' : 'rgba(239,68,68,.12)';
            pill.style.borderColor = ok ? 'rgba(16,185,129,.25)' : 'rgba(239,68,68,.25)';
            pill.style.color = ok ? '#10b981' : '#ef4444';
            setTimeout(() => { pill.style.display = 'none'; }, 1800);
        }

        async function postRuntimeSettings() {
            try {
                const res = await fetch(RUNTIME_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        max_open_before_3pm: maxBefore,
                        max_open_after_3pm: maxAfter
                    })
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                showRuntimeStatus('已保存 ✓', true);
            } catch (e) {
                console.error('Runtime POST error:', e);
                showRuntimeStatus('保存失败', false);
            }
        }

        function setupRuntimeControls() {
            const ids = ['before-inc', 'before-dec', 'after-inc', 'after-dec', 'before-value', 'after-value'];
            if (!ids.every(id => document.getElementById(id))) return; // 未插入控件则跳过

            document.getElementById('before-inc').addEventListener('click', () => {
                maxBefore = clamp(maxBefore + 1);
                updateRuntimeControlsUI();
                postRuntimeSettings();
            });
            document.getElementById('before-dec').addEventListener('click', () => {
                maxBefore = clamp(maxBefore - 1);
                updateRuntimeControlsUI();
                postRuntimeSettings();
            });
            document.getElementById('after-inc').addEventListener('click', () => {
                maxAfter = clamp(maxAfter + 1);
                updateRuntimeControlsUI();
                postRuntimeSettings();
            });
            document.getElementById('after-dec').addEventListener('click', () => {
                maxAfter = clamp(maxAfter - 1);
                updateRuntimeControlsUI();
                postRuntimeSettings();
            });

            updateRuntimeControlsUI();
        }
        // === /Runtime controls (NEW) ===


        function initializeApp() {
            // Initialize webhook ID
            initializeWebhookId();

            // Setup webhook ID input interface
            setupWebhookIdInput();

            // 新增：初始化顶部两个小按钮
            setupRuntimeControls();

            // If we have a webhook ID, start fetching data
            if (webhookId) {
                fetchData();
                setInterval(fetchData, 30000);
            }

            // Setup refresh button
            document.getElementById('refresh-btn').addEventListener('click', fetchData);

            // Audio beep removed: no need to unlock audio context
        }


        // Start the application when page loads
        initializeApp();
    </script>
</body>

</html>
